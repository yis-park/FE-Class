<script>
  /* 
  단락평가(단락회로평가): 논리 연산자의 특성을 이용하여 구문 작성

  truthy: 참인듯
    빈배열 [], 빈객체 {}

  falsy(falsey): 거짓인듯
    false, 0, -0(-1,-2), '', null, undefined, NaN ..

  boolean && 실행문장, boolean || 실행문장
  || OR 연산자
  true || 조건 -> 왼쪽이 참이면 오른쪽은 실행되지 않음
  false || 조건 -> 왼쪽이 거짓이면 오른쪽 내용이 반환

  && AND 연산자 
  false && 조건 -> 왼쪽이 거짓이면 오른쪽은 실행되지 않음
*/

  console.log(false && true); //false
  // A의 값이 거짓인 경우 B의 값을 탐색할 필요도 없이 거짓이 되므로 falsy
  false && console.log(`A가 거짓이면 이 내용은 반환되지 않음`);
  true && console.log(`A가 참이면 이 내용은반환됨`);

  console.log(true && false && true); //false
  // A와 B의 값이 false이기 때문에 C까지 가지 않고 멈춤  falsy

  console.log(true || false); // true
  // A와 B 둘중 하나만 true여도 true 반환
  // A값이 true인 경우 B의 값을 탐색할 필요도 없이 참이므로 truthy
  true || console.log(`A가 참이면 이 내용은 반환되지 않음`);

  console.log(false || true || true); // true
  // A || B 먼저 연산 후 결과값 || C 연산
  // A와 B를 읽어 true가 나오면 C의 값을 탐색할 필요 없이 멈춤 truthy
  false || console.log(`A가 거짓이면 이 내용은 반환됨`);

  console.log("" || "a");
  // 빈 문자열의 경우 falsy의 값이므로 뒤의 값까지 읽어야 함
  // a <- true, false로 연산 후 원래 값으로 반환

  console.log("" || "a" || 222); // a. 222의 값은 탐색하지도 않고 a 출력
  // ''와 'a' 연산 후 a가 참이기 때문에 222까지 넘어가지 않고 thuthy를 만나는 순간 멈춤

  console.log([] && "" && 222); //""
  // [] truthy, '' falsy이기 때문에 222로 넘어가지 못하고 멈춤

  console.log([] && {} && 222);
  // [] {} truthy
  // truthy && 222 -> truthy
</script>
